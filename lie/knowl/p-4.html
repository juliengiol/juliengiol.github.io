<!DOCTYPE html>
<html lang="en-US">
<!--**************************************-->
<!--*    Generated from PreTeXt source   *-->
<!--*    on 2021-02-15T07:21:08-05:00    *-->
<!--*                                    *-->
<!--*      https://pretextbook.org       *-->
<!--*                                    *-->
<!--**************************************-->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="robots" content="noindex, nofollow">
<script>$(function () {
    // Make *any* div with class 'sagecell-sage' an executable Sage cell
    // Their results will be linked, only within language type
    sagecell.makeSagecell({inputLocation: 'div.sagecell-sage',
                           linked: true,
                           languages: ['sage'],
                           evalButtonText: 'Evaluate (Sage)'});
});
</script>
</head>
<body>
<h6 class="heading"><span class="type">Paragraph</span></h6>
<p>Here is the code you need to run first. <div class="sagecell-sage" id="sage-1"><script type="text/x-sage">import copy

Qt.<t> = FunctionField(QQ)

def ShiftTable(Table): # forces index start at 0 and constant length equal to 4
    ST = copy.deepcopy(Table)
    for r in range(len(Table)):
        if len(ST[r]) == 3:
            ST[r].append(1)
        elif len(ST[r]) != 4:
            print('syntax problem with the table entry', ST[r])
        for i in range(3):
            ST[r][i] -= 1
    return ST

def EvalFraction(f, t0):
    if f in QQ:
        return f
    else:
        return f.numerator()(t0) / f.denominator()(t0)

def EvalTable(Table, t0):
    SpTable = copy.deepcopy(Table)
    for r in range(len(Table)):
        if len(Table[r]) == 4:
            f = Table[r][3]
            SpTable[r][3] = EvalFraction(f, t0)
    return SpTable

def FillSC(Field, Dimension, Table): # forces antisymmetry
    SC = []
    Witness = []
    for k in range(Dimension):
        SC.append(matrix(Field, Dimension))
        Witness.append(matrix(Field, Dimension))
    for Constant in Table:
        i, j, k, c = Constant
        if i == j:
            print('antisymmetry problem --> ignored constant', [i+1, j+1, k+1, c])
        else:
            if Witness[k][i, j] == True:
                print('beware duplicate --> ignored constant', [i+1, j+1, k+1, c])
            else:
                SC[k][i, j] = c
                SC[k][j, i] = -c
                Witness[k][i, j] = Witness[k][j, i] = True
    print('antisymmetry ok')
    return SC

def JacobiTest(SC):
    n = len(SC)
    for i in range(n):
        for j in range(n):
            for k in range(n):
                for m in range(n):
                    sum = 0
                    for l in range(n):
                        sum += SC[m][i, l] * SC[l][j, k] + SC[m][j, l] * SC[l][k, i] + SC[m][k, l] * SC[l][i, j]
                    if sum != 0:
                        print('problem with [i, j, k, m] =', [i+1, j+1, k+1, m+1])
                        return 'Jacobi not ok'
    return 'Jacobi ok'

def LieFromTable(Field, Dimension, Table):
    Lie = {'Field': Field, 'Dimension': Dimension}
    STable = ShiftTable(Table)
    Lie['Table'] = STable
    SC = FillSC(Field, Dimension, STable)
    if JacobiTest(SC) != 'Jacobi ok':
        print('Jacobi not ok')
        return Lie
    else:
        print('Jacobi ok')
        Lie['Structure Constants'] = SC
        return Lie
</script></div></p>
<span class="incontext"><a href="jacobiidentity_examples.html#p-4">in-context</a></span>
</body>
</html>
