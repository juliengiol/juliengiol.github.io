<!DOCTYPE html>
<html lang="fr-FR">
<!--********************************************-->
<!--*       Generated from PreTeXt source      *-->
<!--*       on 2021-10-28T12:21:51-04:00       *-->
<!--*   A recent stable commit (2020-08-09):   *-->
<!--* 98f21740783f166a773df4dc83cab5293ab63a4a *-->
<!--*                                          *-->
<!--*         https://pretextbook.org          *-->
<!--*                                          *-->
<!--********************************************-->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="robots" content="noindex, nofollow">
<script>$(function () {
    // Make *any* div with class 'sagecell-sage' an executable Sage cell
    // Their results will be linked, only within language type
    sagecell.makeSagecell({inputLocation: 'div.sagecell-sage',
                           linked: true,
                           languages: ['sage'],
                           evalButtonText: 'Évaluer (Sage)'});
});
</script><script>$(function () {
    // Make *any* div with class 'sagecell-python' an executable Sage cell
    // Their results will be linked, only within language type
    sagecell.makeSagecell({inputLocation: 'div.sagecell-python',
                           linked: true,
                           languages: ['python'],
                           evalButtonText: 'Évaluer (Python)'});
});
</script>
</head>
<body>
<section class="paragraphs"><h5 class="heading"><span class="title">Algorithme 2 : Exponentiation matricielle rapide.</span></h5>
<p xmlns:svg="http://www.w3.org/2000/svg">Nous allons maintenant transformer l'évaluation d'un terme de la suite \((F_n)\) en un problème d'exponentiation grâce au calcul matriciel.</p>
<article class="theorem theorem-like"><h6 xmlns:svg="http://www.w3.org/2000/svg" class="heading">
<span class="type">Théorème</span><span class="space"> </span><span class="codenumber">3.4.4</span><span class="period">.</span>
</h6>
<p>Pour tout \(n\ge 3\text{,}\) on a</p>
<div xmlns:svg="http://www.w3.org/2000/svg" class="displaymath">
\begin{equation*}
\begin{bmatrix}1&amp;1\\1&amp;0\end{bmatrix}^{n-1}=\begin{bmatrix}F_n&amp;F_{n-1}\\F_{n-1}&amp;F_{n-2}\end{bmatrix}.
\end{equation*}
</div></article><article class="hiddenproof"><a class="proof-knowl original" data-knowl="./knowl/proof-2-hidden.html" title="Démonstration 3.4.4.1"><h6 xmlns:svg="http://www.w3.org/2000/svg" class="heading"><span class="type">Démonstration<span class="period">.</span></span></h6></a></article><p xmlns:svg="http://www.w3.org/2000/svg">Évaluez le code suivant pour calculer \(F_{50}\) à l'aide d'une exponentiation matricielle rapide implémentée en Python à l'aide de NumPy. <div class="sagecell-python" id="sage-49"><script type="text/x-sage"># entrée :
n = 49
# instructions :
import numpy as np
M = np.array([[1,1], [1,0]])

def puissanceRecursive(M, n):
    if n == 1:
        return M
    elif n % 2 == 0:
        return puissanceRecursive(M.dot(M.T), n / 2)
    else:
        N = puissanceRecursive(M.dot(M.T), (n - 1) / 2)
        return M.dot(N.T)

N = puissanceRecursive(M, n)
# sortie :
print(N)
</script></div> On en déduit à nouveau que \(F_{50}=12\,586\,269\,025\text{.}\)</p>
<p xmlns:svg="http://www.w3.org/2000/svg">Quoique moins rapide que la formule de Binet, cet algorithme a le mérite de donner des valeurs exactes de \(F_n\) pour des valeurs de \(n\) plus nombreuses. Et si on tient compte de la complexité de l'addition utilisée dans l'approche itérative utilisée dans l'exercice <a class="xref" data-knowl="./knowl/fibo_iterative.html" title="Exercice 1.4.12">1.4.12</a>, il s'avère plus rapide que cette dernière.</p>
<p xmlns:svg="http://www.w3.org/2000/svg">Atttention : Notez toutefois que cette implémentation pose un problème à partir de \(n=92\text{.}\) Pour aller plus loin sans erreur, on peut <a class="external" href="https://tinyurl.com/43r32vwy" target="_blank">utiliser Sage</a>, par exemple.</p></section><span class="incontext"><a href="fibonacci.html#paragraphs-10">Contexte</a></span>
</body>
</html>
